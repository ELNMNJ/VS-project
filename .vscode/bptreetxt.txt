#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_KEYS 4  // Order of B+ tree (maximum number of keys in a node)
#define MIN_KEYS ((MAX_KEYS + 1) / 2)

// B+ Tree Node Structure
typedef struct Node {
    bool is_leaf;
    int num_keys;
    int keys[MAX_KEYS];
    struct Node* children[MAX_KEYS + 1];
    struct Node* next_leaf;  // Only used for leaf nodes
} Node;

// Function prototypes
Node* create_node(bool is_leaf);
void insert(Node** root, int key);
Node* split_node(Node* node);
void print_tree(Node* root);
void delete_key(Node** root, int key);
Node* find_leaf(Node* root, int key);
void redistribute_keys(Node* left, Node* right, Node* parent, int parent_index);
void merge_nodes(Node** root, Node* left, Node* right, Node* parent, int parent_index);

// Create a new node
Node* create_node(bool is_leaf) {
    Node* new_node = (Node*)malloc(sizeof(Node));
    new_node->is_leaf = is_leaf;
    new_node->num_keys = 0;
    new_node->next_leaf = NULL;
    for (int i = 0; i < MAX_KEYS + 1; i++) {
        new_node->children[i] = NULL;
    }
    return new_node;
}

// Insert a key into the B+ tree
void insert(Node** root, int key) {
    if (*root == NULL) {
        *root = create_node(true);
        (*root)->keys[0] = key;
        (*root)->num_keys = 1;
        return;
    }

    Node* current = *root;
    Node* parent = NULL;
    
    // Find the leaf node where the key should be inserted
    while (!current->is_leaf) {
        parent = current;
        int i;
        for (i = 0; i < current->num_keys; i++) {
            if (key < current->keys[i]) {
                current = current->children[i];
                break;
            }
        }
        if (i == current->num_keys) {
            current = current->children[i];
        }
    }

    // Insert key into leaf node
    int i;
    for (i = current->num_keys; i > 0 && current->keys[i-1] > key; i--) {
        current->keys[i] = current->keys[i-1];
    }
    current->keys[i] = key;
    current->num_keys++;

    // Handle node splitting
    if (current->num_keys > MAX_KEYS) {
        Node* new_node = split_node(current);
        
        if (parent == NULL) {
            // Create new root if splitting root
            Node* new_root = create_node(false);
            new_root->keys[0] = new_node->keys[0];
            new_root->num_keys = 1;
            new_root->children[0] = current;
            new_root->children[1] = new_node;
            *root = new_root;
        } else {
            // Insert split node into parent
            int j;
            for (j = parent->num_keys; j > 0 && parent->keys[j-1] > new_node->keys[0]; j--) {
                parent->keys[j] = parent->keys[j-1];
                parent->children[j+1] = parent->children[j];
            }
            parent->keys[j] = new_node->keys[0];
            parent->children[j+1] = new_node;
            parent->num_keys++;
        }
    }
}

// Split an overflowing node
Node* split_node(Node* node) {
    Node* new_node = create_node(node->is_leaf);
    int mid = (MAX_KEYS + 1) / 2;

    // Copy second half of keys to new node
    for (int i = mid; i < MAX_KEYS; i++) {
        new_node->keys[new_node->num_keys++] = node->keys[i];
    }

    if (!node->is_leaf) {
        // For internal nodes, copy children
        for (int i = mid; i <= MAX_KEYS; i++) {
            new_node->children[new_node->num_keys] = node->children[i];
            node->children[i] = NULL;
        }
    } else {
        // For leaf nodes, link leaf nodes
        new_node->next_leaf = node->next_leaf;
        node->next_leaf = new_node;
    }

    // Reduce keys in original node
    node->num_keys = mid;

    return new_node;
}

// Delete a key from the B+ tree
void delete_key(Node** root, int key) {
    if (*root == NULL) return;

    Node* leaf = find_leaf(*root, key);
    if (leaf == NULL) return;

    // Find and remove the key from the leaf
    int i;
    for (i = 0; i < leaf->num_keys; i++) {
        if (leaf->keys[i] == key) {
            break;
        }
    }

    if (i == leaf->num_keys) return;  // Key not found

    // Remove the key by shifting
    for (int j = i; j < leaf->num_keys - 1; j++) {
        leaf->keys[j] = leaf->keys[j+1];
    }
    leaf->num_keys--;

    // Handle underflow
    if (leaf->num_keys < MIN_KEYS) {
        Node* parent = *root;
        Node* sibling = NULL;
        int parent_index = -1;

        // Find parent and determine sibling
        while (parent != NULL && !parent->is_leaf) {
            for (i = 0; i <= parent->num_keys; i++) {
                if (parent->children[i] == leaf) {
                    parent_index = i;
                    
                    // Try left sibling first
                    if (i > 0) {
                        sibling = parent->children[i-1];
                        if (sibling->num_keys > MIN_KEYS) {
                            redistribute_keys(sibling, leaf, parent, parent_index);
                            return;
                        }
                    }
                    
                    // Try right sibling
                    if (i < parent->num_keys) {
                        sibling = parent->children[i+1];
                        if (sibling->num_keys > MIN_KEYS) {
                            redistribute_keys(leaf, sibling, parent, parent_index);
                            return;
                        }
                    }

                    // If redistribution not possible, merge
                    if (i > 0) {
                        merge_nodes(root, parent->children[i-1], leaf, parent, parent_index - 1);
                    } else {
                        merge_nodes(root, leaf, parent->children[i+1], parent, parent_index);
                    }
                    return;
                }
            }
            parent = NULL;  // Reset to break out of while loop
        }
    }
}

// Redistribute keys between nodes
void redistribute_keys(Node* left, Node* right, Node* parent, int parent_index) {
    if (left->num_keys > right->num_keys) {
        // Move keys from left to right
        right->keys[right->num_keys] = left->keys[left->num_keys - 1];
        right->num_keys++;
        left->num_keys--;
        parent->keys[parent_index] = right->keys[0];
    } else {
        // Move keys from right to left
        left->keys[left->num_keys] = right->keys[0];
        left->num_keys++;
        
        // Shift keys in right node
        for (int i = 0; i < right->num_keys - 1; i++) {
            right->keys[i] = right->keys[i+1];
        }
        right->num_keys--;
        parent->keys[parent_index] = right->keys[0];
    }
}

// Merge two adjacent nodes
void merge_nodes(Node** root, Node* left, Node* right, Node* parent, int parent_index) {
    // Copy keys from right to left
    for (int i = 0; i < right->num_keys; i++) {
        left->keys[left->num_keys + i] = right->keys[i];
    }
    left->num_keys += right->num_keys;

    // Remove key from parent
    for (int i = parent_index; i < parent->num_keys - 1; i++) {
        parent->keys[i] = parent->keys[i+1];
        parent->children[i+1] = parent->children[i+2];
    }
    parent->num_keys--;

    // Free the right node
    free(right);

    // If parent becomes empty and is the root, update root
    if (parent->num_keys == 0 && parent == *root) {
        *root = left;
        free(parent);
    }
}

// Find the leaf node containing a key
Node* find_leaf(Node* root, int key) {
    if (root == NULL) return NULL;
    
    Node* current = root;
    while (!current->is_leaf) {
        int i;
        for (i = 0; i < current->num_keys; i++) {
            if (key < current->keys[i]) {
                current = current->children[i];
                break;
            }
        }
        if (i == current->num_keys) {
            current = current->children[i];
        }
    }
    return current;
}

// Print the B+ tree (in-order traversal)
void print_tree(Node* root) {
    if (root == NULL) return;

    if (root->is_leaf) {
        printf("Leaf: ");
        for (int i = 0; i < root->num_keys; i++) {
            printf("%d ", root->keys[i]);
        }
        printf("\n");
    } else {
        for (int i = 0; i <= root->num_keys; i++) {
            print_tree(root->children[i]);
            if (i < root->num_keys) {
                printf("Key: %d\n", root->keys[i]);
            }
        }
    }
}

int main() {
    Node* root = NULL;

    // Insert some keys
    insert(&root, 10);
    insert(&root, 20);
    insert(&root, 5);
    insert(&root, 15);
    insert(&root, 30);
    insert(&root, 25);

    printf("Initial Tree:\n");
    print_tree(root);

    // Delete some keys
    delete_key(&root, 15);
    printf("\nAfter deleting 15:\n");
    print_tree(root);

    delete_key(&root, 20);
    printf("\nAfter deleting 20:\n");
    print_tree(root);

    return 0;